# 🚗 자동차 경주 게임: 아이템 모드 추가와 React Router 도입기

> 우아한테크코스 4~5주차 협업 프로젝트 - 클래식 모드에 아이템 모드를 추가하고, URL 기반 네비게이션으로 개선한 이야기

## 프롤로그: 클래식 모드만 있는 게임

백엔드 분과 협업으로 만든 자동차 경주 게임.

```
localhost:3000 접속
  ↓
차 이름 입력 (pobi, woni, jun)
  ↓
시도 횟수 입력 (5)
  ↓
레이싱 애니메이션
  ↓
우승자 발표! 🏆
```

심플하고 괜찮았다. 하지만...

"이것만 있으면 좀 심심한데? 🤔"

---

## 1단계: 아이템 모드를 만들어보자!

### 아이디어 구상

**클래식 모드 (기존):**
- 입력: 시도 횟수 (예: 5회)
- 이동: 매 턴마다 0~1칸 랜덤
- 종료: 정해진 라운드 완료
- 특징: 순수한 운

**아이템 모드 (새로운):**
- 입력: 목표 거리 (예: 30칸)
- 이동: 아이템 효과로 -3 ~ +5칸
- 종료: 한 대 이상이 목표 거리 도달
- 특징: 후퇴 가능! (단, 0 미만으로는 안 내려감)

"좋아! 이렇게 가자!"

### 아이템 6종 설계

```javascript
// frontend/src/constants/itemMode.js
export const ITEMS = [
  { 
    id: 'LIGHTNING_BREATH', 
    name: '번개의 호흡', 
    icon: '⚡', 
    effect: 5,
    messages: [
      '번개의 호흡 제 1형 벽력일섬!!!', 
      '으아아 못참겠다!!!!!!!!!!!!! 가자!!!!!!!!'
    ]
  },
  { 
    id: 'BOOSTER', 
    name: '부스터', 
    icon: '🚀', 
    effect: 3,
    messages: [
      '부아앙! 부스터 발동!', 
      '차 없는거 봐라ㅋㅋ 슝슝!',
      '앞으로 치고 나가기~zz'
    ]
  },
  { 
    id: 'NICE_WEATHER', 
    name: '날씨 좋음', 
    icon: '☀️', 
    effect: 1,
    messages: [
      '날씨 좋네~', 
      '무난TV', 
      '날이 선선하이 쥑이네~'
    ]
  },
  { 
    id: 'REST_AREA', 
    name: '졸음 쉼터', 
    icon: '😴', 
    effect: 0,
    messages: [
      '졸음 쉼터 zzz', 
      '비가 왜이리 많이오냐', 
      '차가 좀 막히는걸;;'
    ]
  },
  { 
    id: 'THUNDER', 
    name: '천둥 번개', 
    icon: '⛈️', 
    effect: -1,
    messages: [
      '천둥 번개 우르릉 쾅쾅!', 
      '으으 급똥;;'
    ]
  },
  { 
    id: 'TIRE_BOMB', 
    name: '타이어 폭탄', 
    icon: '💣', 
    effect: -3,
    messages: [
      '타이어 BOMB', 
      '리버스 임펙트~', 
      '뒤로뒤로 열매'
    ]
  }
];
```

"메시지도 랜덤으로! 재밌겠다 ㅋㅋ"

### Mock 데이터로 프론트 먼저 개발

백엔드 API가 아직 준비 안 됐으니...

```javascript
// frontend/src/services/itemModeApi.js
const USE_MOCK_DATA = true;  // 백엔드 준비되면 false로 변경

const generateMockRaceData = (carNames, targetDistance) => {
  const raceHistory = [];
  const itemHistory = [];
  const positions = carNames.map(() => 0);
  let round = 0;
  const MAX_ROUNDS = 200;

  while (Math.max(...positions) < targetDistance && round < MAX_ROUNDS) {
    round++;
    const roundItems = [];

    // 🎯 각 차마다 다른 랜덤 아이템!
    positions.forEach((pos, index) => {
      const randomItem = ITEMS[Math.floor(Math.random() * ITEMS.length)];
      const randomMessage = randomItem.messages[
        Math.floor(Math.random() * randomItem.messages.length)
      ];

      roundItems.push({
        carName: carNames[index],
        ...randomItem,
        message: randomMessage
      });

      // 위치 업데이트 (0 미만으로는 안 내려감)
      positions[index] = Math.max(0, pos + randomItem.effect);
    });

    itemHistory.push(roundItems);
    raceHistory.push([...positions]);
  }

  // 우승자 계산
  const maxPosition = Math.max(...positions);
  const winners = carNames.filter((_, index) => positions[index] === maxPosition);

  return {
    raceHistory,
    itemHistory,
    winners,
    finalPositions: positions,
    totalRounds: round
  };
};
```

"Mock으로 테스트 완료! 백엔드 분 API만 연결하면 끝!"

---

## 2단계: 레이싱 UI 만들기 (삽질의 연속)

### 1차 시도: 카드형 UI

```jsx
// 각 차별로 카드 형태
<div className="grid grid-cols-3 gap-4">
  {carNames.map(name => (
    <div className="card">
      <h3>{name}</h3>
      <p>위치: {position}</p>
      <p>아이템: {item.icon} {item.name}</p>
    </div>
  ))}
</div>
```

실행해보고...

"음... 레이싱하는 느낌이 안 나는데?"

### 피드백 1차

> "레이싱할 때 모두가 똑같은 아이템으로 적용되면 레이싱이 무슨 의미임 다 똑같이 들어올텐데 ;;"

"아!!! 각 차마다 다른 아이템이어야지!!!"

### 2차 시도: 여러 줄 트랙

```jsx
// 차마다 별도의 트랙
{carNames.map(name => (
  <div className="track">
    <div className="car" style={{left: `${position}%`}}>
      🏎️ {name}
    </div>
  </div>
))}
```

### 피드백 2차

> "레이싱 별 자동차 현황판을 맨 윗줄에 한줄에 차와 이름으로 구분해놓고 그 밑에 카드 형태로 애네가 어떤 아이템에 걸렸는지 알려주는 ui형태로 고쳐줘."

"아하! 트랙은 하나로 합치고, 아이템 정보는 따로 카드로!"

### 3차 시도: 단일 트랙 + 아이템 카드 분리

```jsx
// 하나의 트랙에 모든 차
<div className="single-track">
  {carNames.map((name, index) => (
    <div 
      className="car"
      style={{
        left: `${progress}%`,
        top: `${(index * 100 / carNames.length)}%`
      }}
    >
      <div className="name">{name}</div>
      🏎️
      <div className="position">{position}/{targetDistance}</div>
    </div>
  ))}
</div>

// 아래에 아이템 카드들
<div className="item-cards">
  {currentRoundItems.map(item => (
    <div className="item-card">
      <div>{item.icon} {item.name}</div>
      <div className="effect">{item.effect > 0 ? '+' : ''}{item.effect}</div>
      <div className="message">{item.message}</div>
    </div>
  ))}
</div>
```

### 피드백 3차

> "줄 하나로 합치고, 이름이랑 골 안보이잖아 임마"

"ㅋㅋㅋㅋ 맞네 차 위에 이름 붙이고 골 표시도 명확하게!"

### 최종 버전

```jsx
<div className="relative h-32">
  {/* 트랙 배경 */}
  <div className="absolute inset-0 bg-gradient-to-r from-gray-700/50 to-gray-800/50 rounded-xl">
    {/* 거리 표시선들 */}
    <div className="absolute inset-0 flex">
      {[...Array(11)].map((_, i) => (
        <div key={i} className="flex-1 border-r border-white/10"></div>
      ))}
    </div>
    
    {/* 🏁 목표선 */}
    <div className="absolute right-0 top-0 bottom-0 w-2 bg-yellow-400">
      <div className="absolute -right-14 top-1/2 -translate-y-1/2 text-yellow-400 font-bold">
        🏁 GOAL
      </div>
    </div>
  </div>

  {/* 모든 자동차 */}
  {carNames.map((name, index) => {
    const progress = (position / targetDistance) * 100;
    const verticalPosition = (index * (100 / carNames.length)) + (50 / carNames.length);

    return (
      <div
        key={name}
        className="absolute transition-all duration-1000"
        style={{
          left: `${Math.min(progress, 95)}%`,
          top: `${verticalPosition}%`
        }}
      >
        {/* 차량 이름 (위에) */}
        <div className="absolute -top-10 left-1/2 -translate-x-1/2 font-bold">
          {name}
        </div>
        
        {/* 차량 아이콘 */}
        <div className="text-4xl">🏎️</div>
        
        {/* 위치 정보 (아래) */}
        <div className="absolute -bottom-7 left-1/2 -translate-x-1/2 text-white text-xs">
          {position}/{targetDistance}
        </div>
      </div>
    );
  })}
</div>

{/* 아이템 카드 (동적 너비, 한 줄에 다 보이게!) */}
<div className="flex gap-3 overflow-x-auto">
  {currentRoundItems.map(item => (
    <div
      key={item.carName}
      className="flex-shrink-0 p-4 rounded-2xl"
      style={{
        width: `${100 / currentRoundItems.length - 1}%`,
        minWidth: '200px'  // 최소 너비 보장
      }}
    >
      <div className="text-2xl">{item.icon}</div>
      <div className="font-bold">{item.name}</div>
      <div className="text-3xl">{item.effect > 0 ? '+' : ''}{item.effect}</div>
      <div className="text-sm italic">{item.message}</div>
      <div className="text-xs">{item.carName}</div>
    </div>
  ))}
</div>
```

"드디어!!! 경주하는 느낌 제대로 난다! 🏎️💨"

---

## 3단계: main 브랜치와 Merge

### 상황 파악

```
내 로컬 작업:
  - 아이템 모드 완성 ✅
  
main 브랜치:
  - 백엔드 분이 뭔가 PR 올리심
  - 확인 필요
```

### main에서 pull

```bash
git checkout main
git pull origin main
```

"어? 백엔드 코드 업데이트가 있네?"

### 충돌 없이 Merge

```bash
# 내 아이템 모드 브랜치로 돌아가서
git checkout feat/item-mode

# main의 변경사항 가져오기
git merge main
```

"오! 충돌 없이 깔끔하게 merge 됐다! 🎉"

---

## 4단계: 모드 선택 화면 추가

이제 클래식과 아이템 두 모드가 있으니 선택 화면이 필요하다!

### ModeSelectionScreen 생성

```jsx
// frontend/src/components/ModeSelectionScreen.jsx
function ModeSelectionScreen({ onSelectMode }) {
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-indigo-900">
      {/* 배경 애니메이션 (자동차들이 움직이는 효과) */}
      <div className="racing-cars">
        <div className="car car-1">🏎️</div>
        <div className="car car-2">🏁</div>
        <div className="car car-3">🚗</div>
        <div className="car car-4">🚙</div>
      </div>

      <div className="max-w-2xl w-full relative z-10">
        <h1 className="text-5xl font-bold text-white">
          🏎️ 자동차 경주 게임
        </h1>
        <p className="text-gray-200">플레이할 모드를 선택하세요</p>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* 클래식 모드 */}
          <button
            onClick={() => onSelectMode('classic')}
            className="bg-white/95 backdrop-blur-sm rounded-2xl p-8 hover:scale-105"
          >
            <div className="text-6xl">🏁</div>
            <h2 className="text-2xl font-bold">클래식 모드</h2>
            <p className="text-gray-600">
              기본 레이싱 게임을 즐겨보세요.
              <br />
              순수한 운으로 승부하는 모드입니다.
            </p>
          </button>

          {/* 아이템 모드 */}
          <button
            onClick={() => onSelectMode('item')}
            className="bg-white/95 backdrop-blur-sm rounded-2xl p-8 hover:scale-105"
          >
            <div className="text-6xl">🎁</div>
            <h2 className="text-2xl font-bold">아이템 모드</h2>
            <p className="text-gray-600">
              다양한 아이템으로 더욱 재미있게!
              <br />
              전략적인 플레이를 즐겨보세요.
            </p>
          </button>
        </div>
      </div>
    </div>
  );
}
```

### App.jsx 수정 (상태 기반)

```jsx
function App() {
  const [selectedMode, setSelectedMode] = useState(null);
  const classicMode = useRacingGame();
  const itemMode = useItemModeGame();

  return (
    <div className="App">
      {/* 모드 선택 */}
      {!selectedMode && (
        <ModeSelectionScreen onSelectMode={setSelectedMode} />
      )}

      {/* 클래식 모드 */}
      {selectedMode === 'classic' && (
        <>
          {classicMode.gameState === 'input' && <InputForm />}
          {classicMode.gameState === 'racing' && <RacingScreen />}
          {classicMode.gameState === 'result' && <ResultScreen />}
        </>
      )}

      {/* 아이템 모드 */}
      {selectedMode === 'item' && (
        <>
          {itemMode.gameState === 'input' && <ItemModeInputForm />}
          {itemMode.gameState === 'racing' && <ItemModeRacingScreen />}
          {itemMode.gameState === 'result' && <ItemModeResultScreen />}
        </>
      )}
    </div>
  );
}
```

"완성! 이제 두 모드를 선택할 수 있다!"

---

## 5단계: "URL로 관리하고 싶은데...?"

게임을 테스트하다가 문제 발견.

### 문제점들

```
1. 주소창이 항상 localhost:3000
   - 어디 있는지 모르겠음

2. 브라우저 뒤로가기 안 됨
   - 게임 중 뒤로가기 누르면 다른 사이트로...

3. 새로고침하면 초기화
   - 레이싱 중에 F5 누르면 모든 게 날아감

4. URL 공유 불가
   - 친구한테 "여기 봐봐" 할 수가 없음
```

"이건... 좀 아닌데? 🤔"

"**URL로 관리하고 싶어서** React Router를 추가해보자!"

---

## 6단계: React Router 도입

### 설치

```bash
cd frontend
npm install react-router-dom
```

### URL 구조 설계

```
/                    → 모드 선택

/classic             → 클래식 입력
/classic/race        → 클래식 레이싱
/classic/result      → 클래식 결과
/classic/history     → 클래식 우승자 기록

/item                → 아이템 입력
/item/race           → 아이템 레이싱
/item/result         → 아이템 결과
/item/history        → 아이템 우승자 기록
```

"계층 구조가 명확하네! 좋아!"

### App.jsx 완전 재작성

**Before (상태 기반, 150줄):**

```jsx
function App() {
  const [selectedMode, setSelectedMode] = useState(null);
  const classicMode = useRacingGame();
  const itemMode = useItemModeGame();

  // 수많은 조건문들...
  if (!selectedMode) return <ModeSelectionScreen />;
  if (selectedMode === 'classic') {
    if (gameState === 'input') return <InputForm />;
    if (gameState === 'racing') return <RacingScreen />;
    // ...
  }
  // ...
}
```

**After (URL 기반, 33줄!):**

```jsx
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import ModeSelectionScreen from './components/ModeSelectionScreen';
import ClassicModePage from './pages/ClassicModePage';
import ItemModePage from './pages/ItemModePage';

function App() {
  return (
    <BrowserRouter>
      <div className="App">
        <Routes>
          {/* 홈 - 모드 선택 */}
          <Route path="/" element={<ModeSelectionScreen />} />
          
          {/* 클래식 모드 */}
          <Route path="/classic/*" element={<ClassicModePage />} />
          
          {/* 아이템 모드 */}
          <Route path="/item/*" element={<ItemModePage />} />
          
          {/* 404 처리 */}
          <Route path="*" element={<Navigate to="/" replace />} />
        </Routes>
      </div>
    </BrowserRouter>
  );
}
```

"150줄이 33줄로!!! 🎉"

### 페이지 컴포넌트 생성

```
frontend/src/
├── App.jsx                          # 최상위 라우팅
├── pages/                           # 🆕 새로 만듦!
│   ├── ClassicModePage.jsx         # 클래식 모드 관리
│   └── ItemModePage.jsx            # 아이템 모드 관리
└── components/
```

**ClassicModePage.jsx:**

```jsx
import { Routes, Route, Navigate, useNavigate } from 'react-router-dom';
import { useRacingGame } from '../hooks/useRacingGame';

function ClassicModePage() {
  const navigate = useNavigate();
  const classicMode = useRacingGame();

  const handleStartGame = async (carNames, attemptCount) => {
    await classicMode.startGame(carNames, attemptCount);
    navigate('/classic/race');  // 🎯 URL 변경!
  };

  const handleRaceComplete = () => {
    classicMode.showResult();
    navigate('/classic/result');  // 🎯 결과 화면으로!
  };

  return (
    <Routes>
      <Route path="/" element={<InputForm onStartGame={handleStartGame} />} />
      <Route path="/race" element={<RacingScreen onComplete={handleRaceComplete} />} />
      <Route path="/result" element={<ResultScreen onRestart={() => navigate('/classic')} />} />
      <Route path="/history" element={<WinnersHistoryScreen />} />
    </Routes>
  );
}
```

**ItemModePage.jsx:**

```jsx
// ClassicModePage와 구조 동일!
function ItemModePage() {
  const navigate = useNavigate();
  const itemMode = useItemModeGame();

  return (
    <Routes>
      <Route path="/" element={<ItemModeInputForm />} />
      <Route path="/race" element={<ItemModeRacingScreen />} />
      <Route path="/result" element={<ItemModeResultScreen />} />
      <Route path="/history" element={<WinnersHistoryScreen />} />
    </Routes>
  );
}
```

### ModeSelectionScreen 수정

**Before:**

```jsx
function ModeSelectionScreen({ onSelectMode }) {
  return (
    <button onClick={() => onSelectMode('classic')}>클래식</button>
  );
}
```

**After:**

```jsx
import { useNavigate } from 'react-router-dom';

function ModeSelectionScreen() {
  const navigate = useNavigate();  // 🎯 직접 URL 변경!

  return (
    <button onClick={() => navigate('/classic')}>클래식</button>
  );
}
```

---

## 놀라운 결과들

### 1. 브라우저 뒤로가기 작동! 🎉

```
사용자: 클래식 입력 → 레이싱 → 결과
        (뒤로가기 클릭)
브라우저: /classic/result → /classic/race
화면: 자동으로 레이싱 화면으로!
```

"와... 진짜 웹 같다!!!"

### 2. URL 공유 가능!

```
친구에게: "http://localhost:3000/item"
친구: (클릭)
결과: 바로 아이템 모드 입력 화면!
```

### 3. 주소창이 직관적!

```
Before: localhost:3000 (항상 똑같음)

After:
  localhost:3000/                 ← 모드 선택
  localhost:3000/classic          ← 클래식 입력
  localhost:3000/classic/race     ← 레이싱 중
  localhost:3000/item             ← 아이템 모드
  localhost:3000/item/race        ← 아이템 레이싱 중
```

"URL만 봐도 어디 있는지 딱 알겠다!"

### 4. 코드가 엄청 깔끔해짐

```
App.jsx:    150줄 → 33줄 (78% 감소)
조건문:     중첩 지옥 → 명확한 Route
상태 관리:  복잡함 → 단순함
```

---

## 최종 프로젝트 구조

```
collob-racing/
├── frontend/
│   ├── src/
│   │   ├── App.jsx                          # Router 최상위
│   │   ├── pages/                           # 🆕
│   │   │   ├── ClassicModePage.jsx         # 클래식 라우팅
│   │   │   └── ItemModePage.jsx            # 아이템 라우팅
│   │   ├── components/
│   │   │   ├── ModeSelectionScreen.jsx     # 모드 선택
│   │   │   ├── InputForm.jsx               # 클래식 입력
│   │   │   ├── RacingScreen.jsx            # 클래식 레이싱
│   │   │   ├── ResultScreen.jsx            # 클래식 결과
│   │   │   ├── ItemModeInputForm.jsx       # 🎁 아이템 입력
│   │   │   ├── ItemModeRacingScreen.jsx    # 🎁 아이템 레이싱
│   │   │   ├── ItemModeResultScreen.jsx    # 🎁 아이템 결과
│   │   │   └── WinnersHistoryScreen.jsx    # 공통 우승자 기록
│   │   ├── hooks/
│   │   │   ├── useRacingGame.js            # 클래식 상태 관리
│   │   │   └── useItemModeGame.js          # 🎁 아이템 상태 관리
│   │   ├── services/
│   │   │   ├── racingApi.js                # 클래식 API
│   │   │   └── itemModeApi.js              # 🎁 아이템 API (Mock)
│   │   ├── constants/
│   │   │   └── itemMode.js                 # 🎁 아이템 정의
│   │   └── utils/
│   │       └── itemModeValidator.js        # 🎁 검증
│   └── package.json
└── backend/
    └── spring/
```

---

## 핵심 학습 포인트

### 1. 기능 추가는 단계적으로

```
1️⃣ 아이템 모드 기획
2️⃣ Mock 데이터로 프론트 먼저 구현
3️⃣ UI 피드백 받으며 개선 (3번!)
4️⃣ main과 merge
5️⃣ 모드 선택 화면 추가
6️⃣ React Router로 개선
```

"한 번에 다 하려고 하면 망한다!"

### 2. Mock 데이터의 힘

백엔드 API 기다릴 필요 없이:
- 프론트 로직 먼저 구현
- UI/UX 테스트
- 백엔드 API 스펙 명확하게 전달

"개발 속도가 엄청 빨라진다!"

### 3. 피드백 적극 수용

```
1차: "카드형 UI" → 경주 느낌 안 남
2차: "여러 줄 트랙" → 아이템 정보 안 보임
3차: "단일 트랙 + 카드" → 골 표시 안 보임
최종: "완벽!" ✨
```

"3번 고치니까 완전 다른 게임이 됐다!"

### 4. 상태 vs URL

| 구분 | 상태 기반 | URL 기반 |
|------|----------|---------|
| **URL 변경** | ❌ | ✅ |
| **뒤로가기** | ❌ | ✅ |
| **새로고침** | ❌ 초기화 | ✅ 화면 유지 |
| **공유** | ❌ | ✅ |
| **북마크** | ❌ | ✅ |
| **코드 복잡도** | 🔥🔥🔥 | 🟢 |

### 5. React Router 핵심

```jsx
// 1. URL 감시
<BrowserRouter>

// 2. URL-컴포넌트 매핑
<Routes>
  <Route path="/classic" element={<ClassicPage />} />
</Routes>

// 3. 페이지 이동
const navigate = useNavigate();
navigate('/classic');
```

"이것만 알면 90% 끝!"

---

## 회고

### 아이템 모드 만들 때

"새로운 모드 추가하는 거 생각보다 재밌네!" 😊

"UI 피드백 받으면서 고치는 게 진짜 개발이구나!" 💪

"Mock 데이터 짱이다!" 🚀

### main과 merge 할 때

"충돌 없이 merge 되니까 기분 좋다!" 😌

"백엔드 분이 뭐 올렸는지 확인하는 습관 중요!" 🔍

### React Router 도입 후

"150줄이 33줄로... 이게 진짜야???" 😲

"뒤로가기 되는 거 보고 소름 돋았음" 🤯

"이제 제대로 된 웹 같다!" 🎉

### 최종 소감

**"클래식만 있던 게임이 완전 다른 게임이 됐다!"**

- 아이템 모드로 재미 2배
- URL 기반 네비게이션으로 UX 10배
- 코드 구조 깔끔
- 협업하기 편해짐

"이게 바로 성장이구나!" 🌱

---

## 다음 과제

- [ ] 백엔드 아이템 모드 API 연동 (`USE_MOCK_DATA = false`)
- [ ] 아이템/클래식 우승자 기록 API 분리
- [ ] 아이템 모드 추가 아이템 (더 다양하게!)
- [ ] 로딩 스피너 추가
- [ ] 에러 바운더리
- [ ] TypeScript 도입 고려

---

## 커밋 로그

```bash
# 아이템 모드 추가
git commit -m "feat: 아이템 모드 구현 및 Mock 테스트"

# main과 merge
git checkout main
git pull origin main
git checkout feat/item-mode
git merge main

# 모드 선택 화면
git commit -m "feat: 모드 선택 화면 추가"

# React Router 도입
git commit -m "url로 관리하고 싶어서 추가해봤습니다!"
```

단순하지만 솔직한 커밋! 😄

---

**GitHub Repository**: [sorrybro2/collab-racing](https://github.com/sorrybro2/collab-racing)

**작성자**: 트루 (sorrybro2)  
**작성일**: 2024년 11월 17일  
**프로젝트**: collab-racing (우아한테크코스 협업 프로젝트)

---

## 덤: 백엔드 개발자분께 전달한 API 스펙

```json
// POST /api/item-mode/racing
{
  "carNames": ["pobi", "woni", "jun"],
  "targetDistance": 30
}

// Response
{
  "raceHistory": [
    [0, 0, 0],     // 0라운드
    [5, 3, 1],     // 1라운드
    [8, 6, 4],     // 2라운드
    ...
  ],
  "itemHistory": [
    [  // 1라운드
      {
        "carName": "pobi",
        "id": "BOOSTER",
        "name": "부스터",
        "icon": "🚀",
        "effect": 3,
        "message": "부아앙! 부스터 발동!"
      },
      ...
    ],
    ...
  ],
  "winners": ["pobi"],
  "finalPositions": [30, 28, 25],
  "totalRounds": 12
}
```

"이렇게 명확하게 전달하면 백엔드 분도 편하시겠지!" 😊
